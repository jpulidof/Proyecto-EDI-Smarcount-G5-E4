// i2c_master_write.v
// MÃ³dulo maestro I2C para escritura de 1 byte a un registro

module i2c_master_write (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [6:0] dev_addr,
    input wire [7:0] reg_addr,
    input wire [7:0] data_in,
    output reg done,
    output wire busy,
    inout wire sda,
    output reg scl
);

    // Estados de la FSM
    localparam IDLE   = 0,
               START  = 1,
               SEND_DEV_WRITE = 2,
               SEND_REG_ADDR  = 3,
               SEND_DATA      = 4,
               STOP           = 5;

    reg [2:0] state = IDLE;
    reg [3:0] bit_cnt;
    reg [7:0] shift_reg;
    reg sda_out, sda_dir;
    reg [15:0] clk_cnt;

    assign sda = sda_dir ? sda_out : 1'bz;
    assign busy = (state != IDLE);

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            done <= 0;
            scl <= 1;
            sda_out <= 1;
            sda_dir <= 1;
            clk_cnt <= 0;
        end else begin
            case (state)
                IDLE: begin
                    scl <= 1;
                    sda_out <= 1;
                    sda_dir <= 1;
                    done <= 0;
                    if (start) begin
                        clk_cnt <= 0;
                        state <= START;
                    end
                end

                START: begin
                    sda_out <= 0;  // Start condition
                    clk_cnt <= clk_cnt + 1;
                    if (clk_cnt == 100) begin
                        clk_cnt <= 0;
                        shift_reg <= {dev_addr, 1'b0}; // Write mode
                        bit_cnt <= 7;
                        state <= SEND_DEV_WRITE;
                    end
                end

                SEND_DEV_WRITE: begin
                    scl <= 0;
                    sda_out <= shift_reg[bit_cnt];
                    clk_cnt <= clk_cnt + 1;
                    if (clk_cnt == 100) begin
                        scl <= 1;
                        clk_cnt <= 0;
                        if (bit_cnt == 0) begin
                            shift_reg <= reg_addr;
                            bit_cnt <= 7;
                            state <= SEND_REG_ADDR;
                        end else begin
                            bit_cnt <= bit_cnt - 1;
                        end
                    end
                end

                SEND_REG_ADDR: begin
                    scl <= 0;
                    sda_out <= shift_reg[bit_cnt];
                    clk_cnt <= clk_cnt + 1;
                    if (clk_cnt == 100) begin
                        scl <= 1;
                        clk_cnt <= 0;
                        if (bit_cnt == 0) begin
                            shift_reg <= data_in;
                            bit_cnt <= 7;
                            state <= SEND_DATA;
                        end else begin
                            bit_cnt <= bit_cnt - 1;
                        end
                    end
                end

                SEND_DATA: begin
                    scl <= 0;
                    sda_out <= shift_reg[bit_cnt];
                    clk_cnt <= clk_cnt + 1;
                    if (clk_cnt == 100) begin
                        scl <= 1;
                        clk_cnt <= 0;
                        if (bit_cnt == 0) begin
                            state <= STOP;
                        end else begin
                            bit_cnt <= bit_cnt - 1;
                        end
                    end
                end

                STOP: begin
                    scl <= 1;
                    sda_out <= 1;
                    clk_cnt <= clk_cnt + 1;
                    if (clk_cnt == 100) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule
